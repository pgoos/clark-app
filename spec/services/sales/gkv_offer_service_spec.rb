# frozen_string_literal: true

require "rails_helper"

RSpec.describe Sales::GkvOfferService, :integration do
  let(:subject) { Sales::GkvOfferService.new }

  let!(:category) { create(:category_gkv) }
  let(:mandate) { create(:mandate, :accepted, user: create(:user)) }
  let(:admin) { create(:admin) }

  let(:accept_event) do
    {
      entity:     mandate,
      action:     'accept',
      created_at: 25.hours.ago,
      person:     admin
    }
  end
  let!(:accepted_mandate_event) { BusinessEvent.create(accept_event)}

  let(:whitelist_company) { create(:gkv_company, gkv_whitelisted: true) }
  let(:unlisted_company) { create(:company, ident: "black_fox_insurance") }

  let(:whitelist_inquiry) { create(:inquiry, company: whitelist_company, mandate: mandate) }
  let(:unlisted_inquiry) { create(:inquiry, company: unlisted_company, mandate: mandate) }

  let(:gkv_offer_automation_rule) { double(Sales::Rules::OptimizeGkvRuleTkHkk) }

  def fake_product_creation(inquiry)

    # We need at least three coverages we can show.
    coverage_features = category.coverage_features.select {|cf| cf.value_type == "Text"}
    coverages         = coverage_features.map {|cf| [cf.identifier, ValueTypes::Boolean::TRUE]}.to_h
    expect(coverages.count >= 3).to be_truthy

    # We need a gkv plan for the product creation.
    Plan.create(
      name:      "Some GKV",
      company:   inquiry.company,
      category:  category,
      coverages: coverages
    )

    Domain::Products::GkvProductCreator.new(inquiry.mandate).create_gkv_product

    inquiry.reload
    inquiry.products.first
  end

  context "opportunity creation" do
    let(:cover_and_price_option) { create(:offer_option, recommended: true) }
    let(:price_option) { create(:price_option) }
    let(:old_product_option) { create(:old_product_option) }
    let(:advice_admin) { create(:advice_admin) }
    let(:admin) { create(:admin) }
    let(:fake_product) { fake_product_creation(whitelist_inquiry) }

    let!(:advice) do
      create(
        :advice,
        topic:   fake_product,
        admin:   advice_admin,
        rule_id: "premium_bucket_1"
      )
    end

    let(:old_product) { fake_product }

    before do
      old_product_option.product = old_product
      allow(gkv_offer_automation_rule).to receive(:on_application).and_yield(cover_and_price_option, price_option, old_product_option)
      expect(advice.admin).not_to be_nil
    end

    it "should open an opportunity" do
      expect {
        subject.apply_offer_automation_rule(gkv_offer_automation_rule, old_product)
      }.to change(Opportunity, :count).by(1)
    end

    it "should create the opportunity in the state :initiation_phase" do
      subject.apply_offer_automation_rule(gkv_offer_automation_rule, old_product)
      expect(Opportunity.last.state).to eq("initiation_phase")
    end

    it "should be assigned to the same admin as the advice has" do
      subject.apply_offer_automation_rule(gkv_offer_automation_rule, old_product)
      expect(Opportunity.last.admin).to eq(advice_admin)
    end

    it "should be assigned to the same admin as the newest advice" do
      advice.update_attributes!(admin: admin)

      create(
        :advice,
        topic:   old_product,
        admin:   advice_admin,
        rule_id: "premium_bucket_1"
      )

      subject.apply_offer_automation_rule(gkv_offer_automation_rule, old_product)
      expect(Opportunity.last.admin).to eq(advice_admin)
    end

    it "should have an old_product assigned to the opportunity" do
      subject.apply_offer_automation_rule(gkv_offer_automation_rule, old_product)
      expect(Opportunity.last.old_product).to eq(old_product)
    end

    it "should assign is automated to true if it is generated by rules engine" do
      subject.apply_offer_automation_rule(gkv_offer_automation_rule, old_product)
      expect(Opportunity.last).to be_automated
    end

    context "offer" do
      let(:offer_text) do
        I18n.t("automation.gkv_expert_comment.#{advice.rule_id}")
      end

      it "should be created" do
        expect {
          subject.apply_offer_automation_rule(gkv_offer_automation_rule, old_product)
        }.to change(Offer, :count).by(1)
      end

      it "should show the proper offer text" do
        subject.apply_offer_automation_rule(gkv_offer_automation_rule, old_product)
        expect(Offer.last.note_to_customer).to eq(offer_text)
      end
    end
  end

  context "error handling" do
    before do
      fake_product_creation(whitelist_inquiry)
    end

    it "should handle batch errors when executing the task to send gkv advices" do
      allow(subject).to receive(:apply_advice_automation_rule).and_raise("test exception in task_send_gkv_advices")

      expect(Batch).to receive(:handle_errors).with(sent_advices: 0, product: whitelist_inquiry.products.last)

      Timecop.freeze(Time.now + 1.hour) do
        subject.task_send_gkv_advices
      end
    end

    it "should handle batch errors when executing the task to send gkv advices" do
      allow(subject).to receive(:apply_offer_automation_rule).and_raise("test exception in task_send_gkv_advices")

      expect(Batch).to receive(:handle_errors).with(sent_advices: 0, product: whitelist_inquiry.products.last)

      Timecop.freeze(Time.now + 1.hour) do
        subject.task_send_gkv_advices
      end
    end

    it "should handle batch errors when executing the task to send gkv offers" do
      create(:advice_admin)

      Timecop.freeze(Time.now + 1.hour) do
        subject.task_send_gkv_advices
      end
      allow(subject).to receive(:apply_send_gkv_offer_rule).and_raise("test exception in task_send_gkv_offers")

      expect(Batch).to receive(:handle_errors).with(sent_opportunities: 0, opportunity: Opportunity.last)

      Timecop.freeze(Time.now + 3.hours) do
        subject.task_send_gkv_offers
      end
    end
  end

  context "selecting the right offers and advices" do
    let(:company) { create(:company) }
    let(:plan_whitelisted) { create(:plan, category: category, company: company) }
    let(:plan_unlisted) { create(:plan, category: category, company: create(:company)) }

    context ".select_new_gkv_to_advice" do
      let(:business_hour) { "2016-09-07 14:00:00 +0200".to_time }
      let(:subject_at_business_hour) { Sales::GkvOfferService.new(business_hour) }

      it "includes a valid gkv 1.hour old product" do
        product = create(:product, created_at: 1.hour.ago, mandate: mandate, plan: plan_whitelisted)
        expect(subject_at_business_hour.select_new_gkv_to_advice).to include(product)
      end

      it 'does not include the product if the user accept date is less than 24.hours.ago' do
        accepted_mandate_event.update(created_at: Time.zone.now)
        product = create(:product,
                                     created_at: 1.hour.ago,
                                     mandate:    mandate,
                                     plan:       plan_whitelisted)

        expect(subject_at_business_hour.select_new_gkv_to_advice).not_to include(product)
      end

      it "selects only gkv products" do
        product_non_gkv = create(:product)
        create(:product, created_at: 1.hour.ago, mandate: mandate, plan: plan_whitelisted)

        expect(subject_at_business_hour.select_new_gkv_to_advice).not_to include(product_non_gkv)
      end

      it "selects only those that where created_at > 1.hour.ago" do
        product_young = create(:product, created_at: 1.minute.ago, mandate: mandate, plan: plan_whitelisted)

        expect(subject.select_new_gkv_to_advice).not_to include(product_young)
      end

      it "selects only products that where not advised yet" do
        product = create(:product, created_at: 1.hour.ago, mandate: mandate, plan: plan_whitelisted)

        expect(subject.select_new_gkv_to_advice).to include(product)
        product.update_attributes(interactions: [create(:interaction, mandate: mandate, metadata: {sent: Time.current.to_i})])

        expect(subject.select_new_gkv_to_advice).not_to include(product)
      end
    end

    context ".select_opportunities_to_remind" do
      let(:not_yet_two_hours_ago) { 2.hours.ago.advance(minutes: +1) }

      it "selects only opportunities from gkv products to remind" do
        product = create(:product, created_at: 1.hour.ago, mandate: mandate, plan: plan_whitelisted)
        product.update_attributes(interactions: [create(:interaction, mandate: mandate, created_at: 2.hours.ago, metadata: {sent: 2.hours.ago.to_i})])
        opportunity = create(:opportunity, old_product_id: product.id, state: "initiation_phase")

        expect(subject.select_opportunities_to_remind).to include(opportunity)
      end

      it "selects only opportunities with advices sent > 2.hours.ago" do
        product = create(:product, created_at: 1.hour.ago, mandate: mandate, plan: plan_whitelisted)
        product.update_attributes(interactions: [create(:interaction, mandate: mandate, created_at: not_yet_two_hours_ago, metadata: {sent: not_yet_two_hours_ago.to_i})])
        opportunity = create(:opportunity, old_product_id: product.id, state: "initiation_phase")

        expect(subject.select_opportunities_to_remind).not_to include(opportunity)
      end

      it "does not select opportunities with which the client interacted"
      it "does not select opportunities that where already sent"
      it "does not select opportunities from non GKV products"
    end
  end

  context "#apply_advice_automation_rule" do
    let(:rule) { n_double("rule") }

    it "return zero when rule does not yield" do
      expect_any_instance_of(Sales::Rules::GkvAdviceRule).to receive(:on_application)

      expect(subject.apply_advice_automation_rule(double)).to eq(0)
    end
  end

  context "when the offer was not generated and the opportunity needs to be processed again", :integration do
    let(:opportunity) do
      create(:opportunity, :initiation_phase, category: gkv, old_product: old_gkv_product, mandate: mandate)
    end
    let(:gkv) { Category.gkv }
    let(:old_gkv_product) do
      create(
        :product,
        :details_available,
        mandate: mandate,
        plan: gkv_plan,
        advices: [create(:advice)],
        created_at: 1.hour.ago,
        updated_at: 1.hour.ago
      )
    end
    let(:mandate) { create(:mandate, :accepted) }
    let(:gkv_plan) { create(:plan, category: gkv, company: gkv_whitelisted_company) }
    let(:gkv_whitelisted_company) do
      create(:gkv_company, gkv_whitelisted: true, national_health_insurance_premium_percentage: 1.1)
    end

    let(:process_opportunity) do
      lambda do
        subject.reprocess_assigned_opportunity(opportunity)
        opportunity.reload
      end
    end

    before do
      create_plan_for_offer_option = lambda do |ident|
        subcompany = create(:subcompany, ident: ident) unless Subcompany.where(ident: ident).exists?
        create(:plan, subcompany: subcompany, category: gkv)
      end
      create_plan_for_offer_option.("technfac6e4")
      create_plan_for_offer_option.("handec9db4e")
    end

    it "creates and sends the offer for a processable opportunity" do
      interaction_start_count = mandate.interactions.where(type: "Interaction::SentOffer").count

      expect_any_instance_of(OutboundChannels::DistributionChannels).not_to receive(:build_and_deliver)
      expect { process_opportunity.() }.to change(Offer, :count).by(1)
      expect(opportunity.offer).to be_active
      expect(opportunity).to be_offer_phase
      expect(mandate.interactions.where(type: "Interaction::SentOffer").count).to eq interaction_start_count
    end

    context "when not processable" do
      let(:old_product) { n_instance_double(Product, "old_product", advices: advices) }
      let(:advice) { instance_double(Interaction::Advice) }
      let(:advices) { [advice] }
      let(:rule) { instance_double(Sales::Rules::OptimizeGkvRuleTkHkk) }
      let(:offer) { instance_double(Offer) }

      before do
        allow(Sales::Rules::OptimizeGkvRuleTkHkk)
          .to receive(:new).with(old_product: old_product).and_return(rule)
        allow(rule).to receive(:on_application).with(any_args).and_return(offer)
      end

      it "should process, if the opportunity is in initiation, an old product is given and an advice is given" do
        opportunity = instance_double(Opportunity, initiation_phase?: true, old_product: old_product)

        expect(offer).to receive(:send_offer)

        subject.reprocess_assigned_opportunity(opportunity)
      end

      it "should not process, if the opportunity is not in initiation" do
        opportunity = instance_double(Opportunity, initiation_phase?: false, old_product: old_product)

        expect(offer).not_to receive(:send_offer)

        subject.reprocess_assigned_opportunity(opportunity)
      end

      it "should not process, if the opportunity does not have an old product" do
        opportunity = instance_double(Opportunity, initiation_phase?: true, old_product: nil)

        expect(offer).not_to receive(:send_offer)

        subject.reprocess_assigned_opportunity(opportunity)
      end

      it "should not process no advice is given" do
        opportunity = instance_double(Opportunity, initiation_phase?: true, old_product: old_product)
        advices.clear

        expect(offer).not_to receive(:send_offer)

        subject.reprocess_assigned_opportunity(opportunity)
      end
    end
  end
end
